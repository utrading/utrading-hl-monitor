// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gen

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/utrading/utrading-hl-monitor/internal/models"
)

func newOrderAggregation(db *gorm.DB, opts ...gen.DOOption) orderAggregation {
	_orderAggregation := orderAggregation{}

	_orderAggregation.orderAggregationDo.UseDB(db, opts...)
	_orderAggregation.orderAggregationDo.UseModel(&models.OrderAggregation{})

	tableName := _orderAggregation.orderAggregationDo.TableName()
	_orderAggregation.ALL = field.NewAsterisk(tableName)
	_orderAggregation.ID = field.NewInt64(tableName, "id")
	_orderAggregation.Oid = field.NewInt64(tableName, "oid")
	_orderAggregation.Address = field.NewString(tableName, "address")
	_orderAggregation.Direction = field.NewString(tableName, "direction")
	_orderAggregation.Symbol = field.NewString(tableName, "symbol")
	_orderAggregation.Fills = field.NewField(tableName, "fills")
	_orderAggregation.TotalSize = field.NewFloat64(tableName, "total_size")
	_orderAggregation.WeightedAvgPx = field.NewFloat64(tableName, "weighted_avg_px")
	_orderAggregation.OrderStatus = field.NewString(tableName, "order_status")
	_orderAggregation.LastFillTime = field.NewInt64(tableName, "last_fill_time")
	_orderAggregation.SignalSent = field.NewBool(tableName, "signal_sent")
	_orderAggregation.CreatedAt = field.NewTime(tableName, "created_at")
	_orderAggregation.UpdatedAt = field.NewTime(tableName, "updated_at")

	_orderAggregation.fillFieldMap()

	return _orderAggregation
}

type orderAggregation struct {
	orderAggregationDo

	ALL           field.Asterisk
	ID            field.Int64
	Oid           field.Int64
	Address       field.String
	Direction     field.String
	Symbol        field.String
	Fills         field.Field
	TotalSize     field.Float64
	WeightedAvgPx field.Float64
	OrderStatus   field.String
	LastFillTime  field.Int64
	SignalSent    field.Bool
	CreatedAt     field.Time
	UpdatedAt     field.Time

	fieldMap map[string]field.Expr
}

func (o orderAggregation) Table(newTableName string) *orderAggregation {
	o.orderAggregationDo.UseTable(newTableName)
	return o.updateTableName(newTableName)
}

func (o orderAggregation) As(alias string) *orderAggregation {
	o.orderAggregationDo.DO = *(o.orderAggregationDo.As(alias).(*gen.DO))
	return o.updateTableName(alias)
}

func (o *orderAggregation) updateTableName(table string) *orderAggregation {
	o.ALL = field.NewAsterisk(table)
	o.ID = field.NewInt64(table, "id")
	o.Oid = field.NewInt64(table, "oid")
	o.Address = field.NewString(table, "address")
	o.Direction = field.NewString(table, "direction")
	o.Symbol = field.NewString(table, "symbol")
	o.Fills = field.NewField(table, "fills")
	o.TotalSize = field.NewFloat64(table, "total_size")
	o.WeightedAvgPx = field.NewFloat64(table, "weighted_avg_px")
	o.OrderStatus = field.NewString(table, "order_status")
	o.LastFillTime = field.NewInt64(table, "last_fill_time")
	o.SignalSent = field.NewBool(table, "signal_sent")
	o.CreatedAt = field.NewTime(table, "created_at")
	o.UpdatedAt = field.NewTime(table, "updated_at")

	o.fillFieldMap()

	return o
}

func (o *orderAggregation) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := o.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (o *orderAggregation) fillFieldMap() {
	o.fieldMap = make(map[string]field.Expr, 13)
	o.fieldMap["id"] = o.ID
	o.fieldMap["oid"] = o.Oid
	o.fieldMap["address"] = o.Address
	o.fieldMap["direction"] = o.Direction
	o.fieldMap["symbol"] = o.Symbol
	o.fieldMap["fills"] = o.Fills
	o.fieldMap["total_size"] = o.TotalSize
	o.fieldMap["weighted_avg_px"] = o.WeightedAvgPx
	o.fieldMap["order_status"] = o.OrderStatus
	o.fieldMap["last_fill_time"] = o.LastFillTime
	o.fieldMap["signal_sent"] = o.SignalSent
	o.fieldMap["created_at"] = o.CreatedAt
	o.fieldMap["updated_at"] = o.UpdatedAt
}

func (o orderAggregation) clone(db *gorm.DB) orderAggregation {
	o.orderAggregationDo.ReplaceConnPool(db.Statement.ConnPool)
	return o
}

func (o orderAggregation) replaceDB(db *gorm.DB) orderAggregation {
	o.orderAggregationDo.ReplaceDB(db)
	return o
}

type orderAggregationDo struct{ gen.DO }

type IOrderAggregationDo interface {
	gen.SubQuery
	Debug() IOrderAggregationDo
	WithContext(ctx context.Context) IOrderAggregationDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IOrderAggregationDo
	WriteDB() IOrderAggregationDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IOrderAggregationDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IOrderAggregationDo
	Not(conds ...gen.Condition) IOrderAggregationDo
	Or(conds ...gen.Condition) IOrderAggregationDo
	Select(conds ...field.Expr) IOrderAggregationDo
	Where(conds ...gen.Condition) IOrderAggregationDo
	Order(conds ...field.Expr) IOrderAggregationDo
	Distinct(cols ...field.Expr) IOrderAggregationDo
	Omit(cols ...field.Expr) IOrderAggregationDo
	Join(table schema.Tabler, on ...field.Expr) IOrderAggregationDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IOrderAggregationDo
	RightJoin(table schema.Tabler, on ...field.Expr) IOrderAggregationDo
	Group(cols ...field.Expr) IOrderAggregationDo
	Having(conds ...gen.Condition) IOrderAggregationDo
	Limit(limit int) IOrderAggregationDo
	Offset(offset int) IOrderAggregationDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IOrderAggregationDo
	Unscoped() IOrderAggregationDo
	Create(values ...*models.OrderAggregation) error
	CreateInBatches(values []*models.OrderAggregation, batchSize int) error
	Save(values ...*models.OrderAggregation) error
	First() (*models.OrderAggregation, error)
	Take() (*models.OrderAggregation, error)
	Last() (*models.OrderAggregation, error)
	Find() ([]*models.OrderAggregation, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.OrderAggregation, err error)
	FindInBatches(result *[]*models.OrderAggregation, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.OrderAggregation) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IOrderAggregationDo
	Assign(attrs ...field.AssignExpr) IOrderAggregationDo
	Joins(fields ...field.RelationField) IOrderAggregationDo
	Preload(fields ...field.RelationField) IOrderAggregationDo
	FirstOrInit() (*models.OrderAggregation, error)
	FirstOrCreate() (*models.OrderAggregation, error)
	FindByPage(offset int, limit int) (result []*models.OrderAggregation, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IOrderAggregationDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (o orderAggregationDo) Debug() IOrderAggregationDo {
	return o.withDO(o.DO.Debug())
}

func (o orderAggregationDo) WithContext(ctx context.Context) IOrderAggregationDo {
	return o.withDO(o.DO.WithContext(ctx))
}

func (o orderAggregationDo) ReadDB() IOrderAggregationDo {
	return o.Clauses(dbresolver.Read)
}

func (o orderAggregationDo) WriteDB() IOrderAggregationDo {
	return o.Clauses(dbresolver.Write)
}

func (o orderAggregationDo) Session(config *gorm.Session) IOrderAggregationDo {
	return o.withDO(o.DO.Session(config))
}

func (o orderAggregationDo) Clauses(conds ...clause.Expression) IOrderAggregationDo {
	return o.withDO(o.DO.Clauses(conds...))
}

func (o orderAggregationDo) Returning(value interface{}, columns ...string) IOrderAggregationDo {
	return o.withDO(o.DO.Returning(value, columns...))
}

func (o orderAggregationDo) Not(conds ...gen.Condition) IOrderAggregationDo {
	return o.withDO(o.DO.Not(conds...))
}

func (o orderAggregationDo) Or(conds ...gen.Condition) IOrderAggregationDo {
	return o.withDO(o.DO.Or(conds...))
}

func (o orderAggregationDo) Select(conds ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.Select(conds...))
}

func (o orderAggregationDo) Where(conds ...gen.Condition) IOrderAggregationDo {
	return o.withDO(o.DO.Where(conds...))
}

func (o orderAggregationDo) Order(conds ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.Order(conds...))
}

func (o orderAggregationDo) Distinct(cols ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.Distinct(cols...))
}

func (o orderAggregationDo) Omit(cols ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.Omit(cols...))
}

func (o orderAggregationDo) Join(table schema.Tabler, on ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.Join(table, on...))
}

func (o orderAggregationDo) LeftJoin(table schema.Tabler, on ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.LeftJoin(table, on...))
}

func (o orderAggregationDo) RightJoin(table schema.Tabler, on ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.RightJoin(table, on...))
}

func (o orderAggregationDo) Group(cols ...field.Expr) IOrderAggregationDo {
	return o.withDO(o.DO.Group(cols...))
}

func (o orderAggregationDo) Having(conds ...gen.Condition) IOrderAggregationDo {
	return o.withDO(o.DO.Having(conds...))
}

func (o orderAggregationDo) Limit(limit int) IOrderAggregationDo {
	return o.withDO(o.DO.Limit(limit))
}

func (o orderAggregationDo) Offset(offset int) IOrderAggregationDo {
	return o.withDO(o.DO.Offset(offset))
}

func (o orderAggregationDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IOrderAggregationDo {
	return o.withDO(o.DO.Scopes(funcs...))
}

func (o orderAggregationDo) Unscoped() IOrderAggregationDo {
	return o.withDO(o.DO.Unscoped())
}

func (o orderAggregationDo) Create(values ...*models.OrderAggregation) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Create(values)
}

func (o orderAggregationDo) CreateInBatches(values []*models.OrderAggregation, batchSize int) error {
	return o.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (o orderAggregationDo) Save(values ...*models.OrderAggregation) error {
	if len(values) == 0 {
		return nil
	}
	return o.DO.Save(values)
}

func (o orderAggregationDo) First() (*models.OrderAggregation, error) {
	if result, err := o.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.OrderAggregation), nil
	}
}

func (o orderAggregationDo) Take() (*models.OrderAggregation, error) {
	if result, err := o.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.OrderAggregation), nil
	}
}

func (o orderAggregationDo) Last() (*models.OrderAggregation, error) {
	if result, err := o.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.OrderAggregation), nil
	}
}

func (o orderAggregationDo) Find() ([]*models.OrderAggregation, error) {
	result, err := o.DO.Find()
	return result.([]*models.OrderAggregation), err
}

func (o orderAggregationDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.OrderAggregation, err error) {
	buf := make([]*models.OrderAggregation, 0, batchSize)
	err = o.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (o orderAggregationDo) FindInBatches(result *[]*models.OrderAggregation, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return o.DO.FindInBatches(result, batchSize, fc)
}

func (o orderAggregationDo) Attrs(attrs ...field.AssignExpr) IOrderAggregationDo {
	return o.withDO(o.DO.Attrs(attrs...))
}

func (o orderAggregationDo) Assign(attrs ...field.AssignExpr) IOrderAggregationDo {
	return o.withDO(o.DO.Assign(attrs...))
}

func (o orderAggregationDo) Joins(fields ...field.RelationField) IOrderAggregationDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Joins(_f))
	}
	return &o
}

func (o orderAggregationDo) Preload(fields ...field.RelationField) IOrderAggregationDo {
	for _, _f := range fields {
		o = *o.withDO(o.DO.Preload(_f))
	}
	return &o
}

func (o orderAggregationDo) FirstOrInit() (*models.OrderAggregation, error) {
	if result, err := o.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.OrderAggregation), nil
	}
}

func (o orderAggregationDo) FirstOrCreate() (*models.OrderAggregation, error) {
	if result, err := o.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.OrderAggregation), nil
	}
}

func (o orderAggregationDo) FindByPage(offset int, limit int) (result []*models.OrderAggregation, count int64, err error) {
	result, err = o.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = o.Offset(-1).Limit(-1).Count()
	return
}

func (o orderAggregationDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = o.Count()
	if err != nil {
		return
	}

	err = o.Offset(offset).Limit(limit).Scan(result)
	return
}

func (o orderAggregationDo) Scan(result interface{}) (err error) {
	return o.DO.Scan(result)
}

func (o orderAggregationDo) Delete(models ...*models.OrderAggregation) (result gen.ResultInfo, err error) {
	return o.DO.Delete(models)
}

func (o *orderAggregationDo) withDO(do gen.Dao) *orderAggregationDo {
	o.DO = *do.(*gen.DO)
	return o
}
